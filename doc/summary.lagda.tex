% Created 2023-04-07 Fri 09:02
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{bbm}
\usepackage[greek, english]{babel}
\usepackage{latex/agda}
\DeclareUnicodeCharacter{7522}{\ensuremath { _i}}
\DeclareUnicodeCharacter{8337}{\ensuremath { _e}}
\DeclareUnicodeCharacter{8346}{\ensuremath { _p}}
\DeclareUnicodeCharacter{7523}{\ensuremath { _r}}
\DeclareUnicodeCharacter{8321}{\ensuremath { _1}}
\DeclareUnicodeCharacter{8322}{\ensuremath { _2}}
\DeclareUnicodeCharacter{955}{\ensuremath{\lambda}}
\DeclareUnicodeCharacter{8759}{\ensuremath{::}}
\author{Christa Jenkins}
\date{\today}
\title{AERES: Summary of verification architecture}
\hypersetup{
 pdfauthor={Christa Jenkins},
 pdftitle={AERES: Summary of verification architecture},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.1 (Org mode 9.4.6)}, 
 pdflang={English}}
\begin{document}

\maketitle
\begin{code}[hide]
open import Aeres.Prelude
open import Aeres.Binary

module summary where

open Base256
\end{code}


\section{Operative Notions}
\label{sec:orgf55f06f}

\begin{itemize}
\item \textbf{soundness} If the parser accepts the string, so does the grammar

\item \textbf{completeness} If the grammar accepts the string, so does the parser

\item \textbf{secure completeness} If the grammar accepts the string, so does the parser,
and there are no two distinct ways for the grammar to accept the string.

NOTE TO OMAR: I'm not sure if this is good terminology, or even if it is a
good idea to group completeness (a relation between the grammar and parser)
and uniqueness (a property of the grammar).
\end{itemize}

\section{Overview}
\label{sec:orgbea5f27}

\begin{enumerate}
\item The Aeres external driver is invoked with the filepath of the certificate
chain we wish to check.
The driver invokes Aeres with the contents of this file.

\item Aeres uses its verified PEM parser library to parse the PEM certificate
chain, then decodes the Base64-encoded certificates into a single
bytestring.\footnote{We maybe could have decoded it to a list of bytestrings and
parsed each, come to think of it\ldots{}}

(Sound and complete parsing)

\item Aeres uses its verified X.509 parser library to parse the bytestring into a
list of certificates.

(Sound, complete, secure)

\item Aeres then checks several semantic properties not suitable for expressing
in the grammar (e.g., validity period of cert contains current time)

\item For each cert, Aeres outputs the bytestring serializations for the TBS
certificate, signature, and public key, and also outputs the signature
algorithm OIDLeastBytes

\item The external driver verifies the public key signatures.
\end{enumerate}



\section{Design (Challenges and Solutions)}
\label{sec:orgbb59e4e}

\textbf{Challenge} Our first and most fundamental question is: how shall we represent
the grammar?
Recall that our operative notion of soundness is "if the parser accepts the
string, then so does the grammar."
We also wish for our formulation of the grammar to serve as a readable
formalization of the X.509 and X.690 specification.

\textbf{Solution} In general purpose functional languages, inductive types are a
natural choice for expressing the grammar of a language.
Our choice of formalizing X.509 and X.680 is \emph{inductive families}, the
generalization of inductive types to a dependently typed setting.

Let us consider a simple example: X.690 DER Boolean values.
The BER require that Boolean values consists of a single octet
with \texttt{FALSE} represented by the setting all bits to 0, and the DER further
stipulates that \texttt{TRUE} be represented by setting all bits to 1.
We represent these constraints as follows.

\begin{code}
module BoolExample where
  data BoolRep : Bool → UInt8 → Set where
    falseᵣ : BoolRep false (UInt8.fromℕ 0)
    trueᵣ  : BoolRep true (UInt8.fromℕ 255)
  record BoolValue (@0 bs : List UInt8) : Set where
    constructor mkBoolValue
    field
      v     : Bool
      @0 b  : UInt8
      @0 vᵣ : BoolRep v b
      @0 bs≡ : bs ≡ [ b ]
\end{code}

\begin{enumerate}
\item First, we define a binary relation \AgdaDatatype{BoolRep} that relates Agda
\AgdaDatatype{Bool} values to the octet values specified by X.690 DER
(\AgdaFunction{UInt8.fromℕ} converts a nonnegative unbounded integer to its
\AgdaFunction{UInt8} representation, provided Agda can verify automatically
the given number is less than 256).

\item Next, we define a record \AgdaDatatype{BoolValue} for the representation of
the X.690 Boolean value itself.

\begin{itemize}
\item Each production rule of the grammar, such as \AgdaDatatype{BoolValue}, is
represented by a type family of type
\AgdaSymbol{@}\AgdaSymbol{0}\AgdaSpace{}\AgdaDatatype{List}\AgdaSpace{}\AgdaDatatype{UInt8}\AgdaSpace{}\AgdaSymbol{→}\AgdaSpace{}\AgdaPrimitive{Set},
which we interpret as the type of predicates over bytestrings (we will
explain the \AgdaSymbol{@}\AgdaSymbol{0} business shortly).

\item The fields of the record are the Boolean value \AgdaField{v}, its
bytestring representation \AgdaField{b}, a proof of type
\AgdaDatatype{BoolRep}\AgdaSpace{}\AgdaField{v}\AgdaSpace{}\AgdaField{b}
that \AgdaField{b} is the correct representation of \AgdaField{b}, and a
proof that the bytestring representation of this terminal of the grammar
is the singleton list consisting of \AgdaField{b} (written \AgdaFunction{[}\AgdaSpace{}\AgdaField{b}\AgdaSpace{}\AgdaFunction{]})
\end{itemize}
\end{enumerate}


The \AgdaSymbol{@}\AgdaSymbol{0} annotations on types and fields indicate that
the values are \emph{erased at runtime.}
We do this for two reasons: to reduce the space and time overhead for
executions of Aeres, and to serve as machine-enforced documentation
delineating the parts of the formalization that are purely for the purposes of
verification.
\end{document}