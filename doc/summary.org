# -*- eval: (smartparens-mode); eval: (flyspell-mode); -*-
#+TITLE: AERES: Summary of verification architecture
#+AUTHOR: Christa Jenkins
#+OPTIONS: toc:nil

#+LATEX_HEADER: \usepackage{bbm}
#+LATEX_HEADER: \usepackage[greek,english]{babel}

#+LATEX_HEADER: \usepackage{latex/agda}

#+LATEX_HEADER: \DeclareUnicodeCharacter{7522}{\ensuremath { _i}}
#+LATEX_HEADER: \DeclareUnicodeCharacter{8337}{\ensuremath { _e}}
#+LATEX_HEADER: \DeclareUnicodeCharacter{8346}{\ensuremath { _p}}
#+LATEX_HEADER: \DeclareUnicodeCharacter{7523}{\ensuremath { _r}}
#+LATEX_HEADER: \DeclareUnicodeCharacter{8321}{\ensuremath { _1}}
#+LATEX_HEADER: \DeclareUnicodeCharacter{8322}{\ensuremath { _2}}
#+LATEX_HEADER: \DeclareUnicodeCharacter{955}{\ensuremath{\lambda}}
#+LATEX_HEADER: \DeclareUnicodeCharacter{8759}{\ensuremath{::}}

  #+ATTR_LATEX: :options [hide]
  #+begin_code
open import Aeres.Prelude
open import Aeres.Binary

module summary where

open Base256
  #+end_code


* Operative Notions

  - *soundness* If the parser accepts the string, so does the grammar

  - *completeness* If the grammar accepts the string, so does the parser

  - *secure completeness* If the grammar accepts the string, so does the parser,
    and there are no two distinct ways for the grammar to accept the string.

    NOTE TO OMAR: I'm not sure if this is good terminology, or even if it is a
    good idea to group completeness (a relation between the grammar and parser)
    and uniqueness (a property of the grammar).

* Overview

  1. The Aeres external driver is invoked with the filepath of the certificate
     chain we wish to check.
     The driver invokes Aeres with the contents of this file.

  2. Aeres uses its verified PEM parser library to parse the PEM certificate
     chain, then decodes the Base64-encoded certificates into a single
     bytestring.[fn::We maybe could have decoded it to a list of bytestrings and
     parsed each, come to think of it...]

     (Sound and complete parsing)

  3. Aeres uses its verified X.509 parser library to parse the bytestring into a
     list of certificates.

     (Sound, complete, secure)

  4. Aeres then checks several semantic properties not suitable for expressing
     in the grammar (e.g., validity period of cert contains current time)

  5. For each cert, Aeres outputs the bytestring serializations for the TBS
     certificate, signature, and public key, and also outputs the signature
     algorithm OIDLeastBytes

  6. The external driver verifies the public key signatures.

     

* Design (Challenges and Solutions)
** Grammar
  *Challenge* Our first and most fundamental question is: how shall we represent
  the grammar?
  Recall that our operative notion of soundness is "if the parser accepts the
  string, then so does the grammar."
  We also wish for our formulation of the grammar to serve as a readable
  formalization of the X.509 and X.690 specification.

  *Solution* In general purpose functional languages, inductive types are a
  natural choice for expressing the grammar of a language.
  Our choice of formalizing X.509 and X.680 is /inductive families/, the
  generalization of inductive types to a dependently typed setting.

  Let us consider a simple example: X.690 DER Boolean values.
  The BER require that Boolean values consists of a single octet
  with =FALSE= represented by the setting all bits to 0, and the DER further
  stipulates that =TRUE= be represented by setting all bits to 1.
  We represent these constraints as follows.

  #+begin_code
module BoolExample where
  data BoolRep : Bool → UInt8 → Set where
    falseᵣ : BoolRep false (UInt8.fromℕ 0)
    trueᵣ  : BoolRep true (UInt8.fromℕ 255)
  record BoolValue (@0 bs : List UInt8) : Set where
    constructor mkBoolValue
    field
      v     : Bool
      @0 b  : UInt8
      @0 vᵣ : BoolRep v b
      @0 bs≡ : bs ≡ [ b ]
  #+end_code
  
  1. First, we define a binary relation \AgdaDatatype{BoolRep} that relates Agda
     \AgdaDatatype{Bool} values to the octet values specified by X.690 DER
     (\AgdaFunction{UInt8.fromℕ} converts a nonnegative unbounded integer to its
     \AgdaFunction{UInt8} representation, provided Agda can verify automatically
     the given number is less than 256).

  2. Next, we define a record \AgdaDatatype{BoolValue} for the representation of
     the X.690 Boolean value itself.

     - Each production rule of the grammar, such as \AgdaDatatype{BoolValue}, is
       represented by a type family of type
       \AgdaSymbol{@}\AgdaSymbol{0}\AgdaSpace{}\AgdaDatatype{List}\AgdaSpace{}\AgdaDatatype{UInt8}\AgdaSpace{}\AgdaSymbol{→}\AgdaSpace{}\AgdaPrimitive{Set},
       which we interpret as the type of predicates over bytestrings (we will
       explain the \AgdaSymbol{@}\AgdaSymbol{0} business shortly).

     - The fields of the record are the Boolean value \AgdaField{v}, its
       bytestring representation \AgdaField{b}, a proof of type
       \AgdaDatatype{BoolRep}\AgdaSpace{}\AgdaField{v}\AgdaSpace{}\AgdaField{b}
       that \AgdaField{b} is the correct representation of \AgdaField{b}, and a
       proof that the bytestring representation of this terminal of the grammar
       is the singleton list consisting of \AgdaField{b} (written \AgdaFunction{[}\AgdaSpace{}\AgdaField{b}\AgdaSpace{}\AgdaFunction{]})


  The \AgdaSymbol{@}\AgdaSymbol{0} annotations on types and fields indicate that
  the values are /erased at runtime./
  We do this for two reasons: to reduce the space and time overhead for
  executions of Aeres, and to serve as machine-enforced documentation
  delineating the parts of the formalization that are purely for the purposes of
  verification.
** Parser
